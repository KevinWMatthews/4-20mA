The TimeService implementation is hardware dependent. It depeneds on which chip you use.
Initially, I'm only going to support two callbacks. I'll rig one up to each Tiny26 timer and use the Compare Match interrupt to set a flag.
This flag will be picked up by the main loop, which will execute the callback.

When the tests use TimeService, we need to implement a spy because we don't want the tests to be hardware dependent.

We'll need to think through the timing very thoroughly to see if it actually works.

Main:
  if flag1, execute callback1 and clear flag1
  if flag2, execute callback2 and clear flag2

Timer1 Compare Match Interrupt:
  Set flag1

Timer2 Compare Match Interrupt:
  Set flag2



Alternate idea:
Set Timer1 Compare Interrupt to 1 ms

Increment a series of counters.
If a counter has reached its interval,
  set global flag
  reset counter.
  (Main program will service/clear flag)

Create a callback struct that contains the function pointer, a time interval, a counter, and a global "execute now" flag.

Main:
  If flag is set,
    clear flag
    execute callback function


For testing this method, we'll need a fake HW timer interrupt. Maybe we just need a fake flag counter? Or just a fake flag?

Ok, what am I actually going to write? I want to write the execute bit.
Does our struct need to be volatile? I think the flag does... I wonder if you can do that.



    Clock frequencies:
Clock0 has a prescaler up to 1024.
System clock can be set to 1, 2, 4, or 8 mHz in its default mode.

1mHz / 4 = 250000
If we set our 8-bit counter to match at 250, we will have
250000 Hz / 250 = 1000 Hz interrupts, or 1 interrupt per ms.
:)

8 mHz / 64 = 125000
If we set our 8-bit counter to match at 125, we'll get interrupts at 1 Hz.

We have options!

